---
title: "Business Intelligence Case Challenge"
author: "Franciszek Kornobis, Jędrzej Słupski"
date: "Maj 2024"
output: html_document
---

1.  Wstęp
2.  Opis metod prognozowania
    1.  Analiza regresji
    2.  ARIMA
    3.  Prophet
    4.  STL, TBATS
    5.  Ostateczna predykcja
3.  Przewidywanie
4.  Podsumowanie

### 1. Wstęp

Wyzwanie konkursowe polega na predykcji wskaźnika bezrobocia na lata 2022-2023, na podstawie danych z 2000-2021. Analizę będziemy przeprowadzać przy użyciu języka R w programie RStudio, do obliczeń i przewidywań użyjemy m.in. z bibliotek takich jak *forecast*, *prophet*, *WSTAW POTEM*, do wizualizacji - *ggplot2*, a do utworzenia ostatecznego raportu posłużymy się oprogramowaniem *RMarkdown*.

Wejściowe dane przyjmują formę szeregu czasowego - realizacji *procesu stochastycznego*, którego dziedziną jest czas - w tym przypadku po 12 miesięcy z 22 lat. Procesem stochastycznym $(X_t)_{t \in T}$ nazywamy rodzinę zmiennych losowych z pewnej przestrzeni probabilistycznej, przyjmującą wartości z przestrzeni mierzalnej.

Dane wskaźnika bezrobocia w latach 2000-2021 przedstawiają się w następujący sposób:

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(plotly)
library(gapminder)
library(dplyr)
library(ggfortify)

df <- read.csv('BICCtemp.txt', sep = ';', dec = ",")
df$full_date <- as.Date(paste(df$Rok, df$M.c, "01", sep = "-"))

df %>%
  ggplot(aes(x = full_date, y = Wskaznik, col = Rok)) +
  geom_line() +
  labs(x = 'Czas', y = 'Wskaznik') +
  scale_x_date()
```

Z podziałem na lata:

```{r, echo=FALSE, message=FALSE, warning=FALSE}
ggplotly(
  df %>%
    ggplot(aes(x = M.c, y = Wskaznik, color = Rok)) +
    geom_line() +
    facet_wrap(~ Rok) +
    theme_light() +
    theme(legend.position = 'none', axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
    labs(x = 'Miesiąc', y = 'Wskaźnik') +
    ylim(91,107)
  )
```

Od razu zauważamy, że dane podlegają dostrzegalnemu, nieliniowemu trendowi - wartość wskaźnika spada na początku roku, w okolicy połowy roku wzrasta, by potem delikatnie spadać, lub utrzymywać się aż do października, a na koniec roku znowu wzrasta. Występuje oczywiście sezonowość o okresie 12 miesięcy

By sprawdzić podejrzenia wynikające z wizualnej obserwacji powyższych wykresów, przeprowadzamy dekompozycję STL. Ma ona wskazać składniki szeregu czasowego - jego trend, sezonowość oraz reszty.

```{r, message=FALSE}
library(forecast)

ts_stl <- ts(df$Wskaznik, frequency = 12, start = c(2000,12))
autoplot(mstl(ts_stl),col=ts_stl)
```

Powyższa metoda opiera się na przedstawieniu punktów szeregu czasowego ($y_i, i \in T$) jako suma komponentów sezonowości $s_i$, trendu $t_i$ i reszty $r_i$: $$y_i = s_i + t_i + r_i$$ oraz estymacja owych komponentów. (**CITATION NEEDED**)

Obserwując surowe dane, widzimy pewną anomalię w roku 2020 - wyraźny skok wartości wskaźnika bezrobocia w kwietniu w wyniku wybuchu pandemii COVID-19. To zaburzenie w danych w większości przypadków obniży jakość prognozy, ponieważ trend w tym okresie zostaje naruszony. Z tym problemem możemy poradzić sobie na kilka sposobów. Istnieje opcja podstawienia średniej wartości wskaźnika z każdego miesiąca do odpowiednich miesięcy z 2020. Można wziąć średnie globalne, lub jedynie z kilku ostatnich lat. Nie ma również większych przeszkód, by zupełnie pominąć ten rok w obliczeniach. Zbadamy także ideę, by użyć danych z lat 2000-2019, by "przewidzieć" wartości z 2020, a następnie dokonywać obliczeń przy użyciu nowych danych z 2020 do predykcji 2022-2023. Dokonamy analizy tych metod w rozdziale 3.

### 2. Opis metod prognozowania

#### 2.1 Analiza regresji

#### 2.2 ARIMA

#### 2.3 Prophet

Kolejną metodą przewidywania szeregu czasowego jest Prophet, przedstawiony przez Facebooka.[*] Na wyjściowym szeregu dokonujemy dekompozycji w następujący sposób:
$$y(t) = g(t) + s(t) + h(t) + e_t$$
W tym przypadku $g(t)$ jest funkcją trendu reprezentującą nieokresowe zmiany wartości szeregu czasowego, $s(t)$ jest funkcją zmian okresowych (np. miesięcznych), a $h(t)$ to efekt świąt, występujących w nieregularnych odstępach czasu. Zakładamy, że błąd $e_t$ ma rozkład normalny.
funkcje $g(t)$, $s(t)$, $h(t)$ są estymowane przy użyciu m. in. logistycznego modelu wzrostu oraz szeregów Fouriera, ściślej opisane w [*].

Podstawiając nasze dane uzyskujemy następujące wyniki predykcji:

```{r, message=FALSE, warning=FALSE}
library(prophet)

df_prophet <- df
df_prophet$date <- as.Date(paste(df$Rok, df$M.c, "01", sep = "-"))
df_prophet <- subset(df_prophet, select = c(date, Wskaznik))
colnames(df_prophet) <- c('ds', 'y')
model_prophet <- prophet(df_prophet)
future <- make_future_dataframe(model_prophet,
                                periods = 24,
                                freq = 'month')
forecast <- predict(model_prophet, future)
forecast[c('ds', 'yhat')] %>%
  tail(n = 24)

prophet_plot_components(model_prophet, forecast)
plot(model_prophet, forecast)
```

Na pierwszym wykresie widzimy krzywą trendu wyznaczoną przez model, łącznie z przewidzianymi ostatnimi latami wraz z przedziałem ufności (niebieskie pole na końcu krzywej), na drugim rysunku - uśrednione, ogólne roczne zmiany wskaźnika. Ostatni wykres przedstawia dodatkowo porównanie rzeczywistych danych (czarne punkty) z tymi estymowanymi przez Prophet (niebieska linia, wraz z przedziałem ufności).

Zbadajmy teraz jakość predykcji, kiedy pominiemy rok 2020 w rozważaniach:

```{r, message=FALSE, warning=FALSE, echo=FALSE}
df_no_2020<- df %>% subset(Rok!=2020)

df_prophet2 <- df_no_2020
df_prophet2$date <- as.Date(paste(df_no_2020$Rok, df_no_2020$M.c, "01", sep = "-"))
df_prophet2 <- subset(df_prophet2, select = c(date, Wskaznik))
colnames(df_prophet2) <- c('ds', 'y')
model_prophet2 <- prophet(df_prophet2)
future2 <- make_future_dataframe(model_prophet2,
                                periods = 24,
                                freq = 'month')
forecast2 <- predict(model_prophet2, future2)
```

```{r}
forecast2[c('ds', 'yhat')] %>%
  tail(n = 24)

prophet_plot_components(model_prophet2, forecast2)
```

Obserwujemy, że po wyrzuceniu 2020, linia trendu zdecydowanie się wypłaszcza na koniec badanego okresu. Przez to, że model bierze pod uwagę współczynnik świąt, czyli nieregularnych skoków bananej zmiennej, w tym przypadku warto zostawić dane z 2020, zatem ostatecznie bierzemy pierwotną wersję prognozy.

```{r, echo=FALSE}
PROPHET <- forecast['yhat'] %>%
  tail(n = 24)
rownames(PROPHET) <- 1:24
colnames(PROPHET) <- 'Wskaznik'
PROPHET
```


#### 2.4 STL, TBATS

OPIS

TEORETYCZNY

TEJ

METODY

BIBLIOGRAFIA[**]

```{r, echo=FALSE}
MAPE.error <- function(x, y) {
  result <- mean(abs((x-y)/x)) * 100
  return(result)
}

RMSE.error <- function(x, y) {
  result <- sqrt((sum(x - y)^2)/length(x))
  return(result)
}
```

```{r, message=FALSE, warning=FALSE}
library(forecast)

ts_tbats <- msts(df$Wskaznik, seasonal.periods = 12)
model.ts_tbats <- tbats(ts_tbats)
plot(model.ts_tbats)

model.ts_tbats.forecast <- forecast(model.ts_tbats, h = 24)
plot(model.ts_tbats.forecast)
model.ts_tbats.forecast$mean

df.test <- tail(df$Wskaznik, n = 12 * 2)

ts_tbats.predict <- predict(model.ts_tbats.forecast, df.test)
ts_tbats.test_vs_predicted <- data.frame(df.test, model.ts_tbats.forecast$mean)
matplot(ts_tbats.test_vs_predicted, type = 'l', lty = 1:2, col = 1:2)

MAPE.error(ts_tbats.test_vs_predicted$df.test,
           ts_tbats.test_vs_predicted$model.ts_tbats.forecast.mean)
RMSE.error(ts_tbats.test_vs_predicted$df.test,
           ts_tbats.test_vs_predicted$model.ts_tbats.forecast.mean)
```

WERSJA BEZ 2020

```{r, message=FALSE, warning=FALSE}
ts_tbats2 <- msts(df_no_2020$Wskaznik, seasonal.periods = 12)
model.ts_tbats2 <- tbats(ts_tbats2)
plot(model.ts_tbats2)

model.ts_tbats2.forecast <- forecast(model.ts_tbats2, h = 24)
plot(model.ts_tbats2.forecast)
model.ts_tbats2.forecast$mean

df_no_2020.test <- tail(df_no_2020$Wskaznik, n = 12 * 2)

ts_tbats2.predict <- predict(model.ts_tbats2.forecast, df_no_2020.test)
ts_tbats2.test_vs_predicted <- data.frame(df_no_2020.test, model.ts_tbats2.forecast$mean)
matplot(ts_tbats2.test_vs_predicted, type = 'l', lty = 1:2, col = 1:2)

MAPE.error(ts_tbats2.test_vs_predicted$df_no_2020.test,
           ts_tbats2.test_vs_predicted$model.ts_tbats2.forecast.mean)
RMSE.error(ts_tbats2.test_vs_predicted$df_no_2020.test,
           ts_tbats2.test_vs_predicted$model.ts_tbats2.forecast.mean)
```

KOMENTARZ CZY BIERZEMY Z 2020 CZY BEZ

```{r, echo=FALSE}
TBATS <- model.ts_tbats2.forecast$mean %>% as.data.frame()
colnames(TBATS) <- 'Wskaznik'
TBATS
```

#### 2.5 Ostateczna predykcja

### 3. Przewidywanie

### 4. Podsumowanie

### Literatura

* Taylor SJ, Letham B. Forecasting at Scale. The American Statistician. 2018

** De Livera A.M., Hyndman R.J., Snyder R.D., Forecasting time series with complex seasonal patterns using exponential smoothing. Journal of the American Statistical Association
2011, 106, 1513–1527.
